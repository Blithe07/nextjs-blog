---
title: "Browser URL"
date: "2023-04-24"
category: "browser"
---

# 浏览器地址栏中输入url到页面显示，浏览器发生了什么？
### 知识点
* 浏览器进程以及进程作用
* 浏览器输入url后，内部进程和线程发生了什么
* 用户与浏览器交互，内部进程怎么处理交互事件
---
### 浏览器结构
浏览器分为单线程多进程以及多线程多进程架构的应用软件。
以Chrome为例，则属于多进程多线程架构：

1. Browser线程：浏览器核心进程，负责浏览器自带操作以及底层不可见操作(网络请求，文件访问)   
        a. UI Thread：控制浏览器上的按钮及输入框   
        b. Network Thread：处理网络请求   
        c. Storage Thread：控制文件等的访问
2. Render线程：渲染进程，负责一个t内的显示工作   
        a. Main Thread：主线程   
        b. Work Thread：工作线程(多个)   
        c. Compositor Thread：合成器线程   
        d. Raster Thread：光栅化线程(多个)   
3. Plugin线程：插件进程，负责网页使用的插件   
4. GPU线程；GPU进程，用于处理GPU任务   
---
### 四个进程之间的关系
1. Browser负责监听url的变化并在内部处理请求，将返回结果给到Render;
2. Render解析结果生成对应的DOM Tree，中途遇到CSS JS IMG等资源会通知Browser继续发送请求获取数据并通知Browser需要调用Plugin加载插件资源，执行插件代码;
3. Render计算得到图像帧，交给GPU；
4. GPU将图像帧显示到页面
---
### 多进程的好处
1. 更高的容错性；当其中一个页面崩溃挂掉之后，其他页面还可以正常的运行不收影响
2. 更高的安全性和沙盒性；浏览器对不同进程限制了不同的权限，并为其提供沙盒运行环境，使其更安全更可靠
3. 更高的响应速度；单进程的架构中，各个任务相互竞争抢夺CPU资源，使得浏览器响应速度变慢
---
### 导航过程都发生了什么
1. 网页加载过程   
    a. 处理输入：   
    UI线程根据输入内容区分是搜索关键字还是url，如果是搜索关键词，跳转至默认搜索引擎对应都搜索URL，如果输入的内容是URL，则开始请求URL。   
    b. 开始导航：   
    UI线程将请求条件交给Network线程，此时UI线程将tab图标设为加载状态，然后Network线程进行DNS寻址，建立连接等操作获取响应结果；如果收到301重定向， 则会通知UI线程进行重定向并再次发送网络请求。   
    c. 读取响应：   
    Network线程获取到响应结果后，解析HTTP报文，根据Content-Type区分媒体类型(MIME)，如果是HTML文件，则交给Render进程渲染；如果是文件流，则交给下载管理器处理；此时浏览器还会进行安全检查，对于恶意站点Network线程会展示警告页并不让跨站数据发送到Render进程中。   
    d. 查找Render进程：   
    Network线程确认可以导航到请求页面时，便会通知UI线程数据准备完成，UI线程就会通过IPC机制通知Render线程进行网页渲染；浏览器对本步骤优化：考虑到网络请求获取响应需要时间，所以在b(开始导航)的时候，浏览器已经预先查找和启动了一个渲染进程；如果中间步骤一切顺利，当Network线程接收到数据时，渲染进程已经准备好了；
    但是如果遇到重定向，这个准备好的渲染进程也许就不可用了，这个时候会重新启动一个渲染进程。    
    e. 提交导航：   
    Browser进程发送IPC消息给Render进程确认导航，此时UI线程控制导航栏更新，安全指示符更新（地址前面的小锁），访问历史列表（history tab）更新。   
    f.初始化加载完成：   
    Render进程渲染完页面后，页面会触发onload事件，向Browser进程发送IPC消息，此时UI线程会停止tab图标加载状态。
---
### 网页渲染原理
1. 构建DOM
    Render进程接收到消息后，开始接受来自浏览器进程的数据，这个时候，主线程会解析数据转化为DOM对象。
2. 资源子加载
    构建DOM的过程中，会解析到图片、CSS、JavaScript脚本等资源，这些资源是需要从网络或者缓存中获取的，主线程在构建DOM过程中如果遇到了这些资源，逐一发起请求去获取。
    优化：浏览器也会运行预加载扫描程序，如果HTML中存在img、link等标签，预加载扫描程序会把这些请求传递给Browser进程的Network线程进行资源下载。
3. JavaScript的下载与执行
    构建DOM过程中，如果遇到script标签，渲染引擎会停止对HTML的解析，而去加载执行JS代码，原因在于JS代码可能会改变DOM的结构
    不过也可以在script标签上添加了 async 或 defer 等属性，浏览器会异步的加载和执行JS代码，而不会阻塞渲染。
4. 样式计算
    主线程根据CSS样式选择器计算出的每个DOM元素应该具备的具体样式（浏览器提供默认样式）。
5. 布局
    主线程会遍历DOM 及相关元素的计算样式，构建出包含每个元素的页面坐标信息及盒子模型大小的布局树（Render Tree），遍历过程中，会跳过隐藏的元素（display: none）；
    另外，伪元素虽然在DOM上不可见，但是在布局树上是可见的。
6. 绘制
    绘制阶段，主线程会遍历布局树（layout tree），生成一系列的绘画记录（paint records）。绘画记录可以看做是记录各元素绘制先后顺序的笔记。
7. 合成
    一旦Layer Tress被创建，渲染顺序被确定，主线程会把这些信息通知给合成器线程，合成器线程开始对层次数的每一层进行光栅化。
    合成线程需要将它们切分成块，之后将这些块分别进行发送给一系列raster线程进行光栅化，结束后raster线程会将每个图块的光栅结果存在GPU进程的内存中。
8. 显示
    合成线程就会通过IPC向Browser进程提交一个渲染帧。
    这个时候可能有另外一个合成帧被浏览器进程的UI线程提交以改变浏览器的UI。这些合成帧都会被发送给GPU从而展示在屏幕上。
    如果合成线程收到页面滚动的事件，合成线程会构建另外一个合成帧发送给GPU来更新页面。
---
### 浏览器对事件的处理
以click事件为例，让鼠标点击页面时候，首先接受到事件信息的是Browser线程，但是Browser线程只知道事件发生的类型和发生的位置，具体怎么对这个点击事件进行处理，还是由Tab内的Renderer线程进行的。Browser线程接受到事件后，随后便把事件的信息传递给了渲染进程，渲染进程会找到根据事件发生的坐标，找到目标对象（target），并且运行这个目标对象的点击事件绑定的监听函数（listener）。   

---
### 浏览器对事件的优化
屏幕的帧率是每秒60帧，也就是60fps，但是滚动等事件触发的频率超过了这个数值，这些连续性的事件一般每秒会触发60~120次，假如每一次触发事件都将事件发送到主线程处理，由于屏幕的刷新速率相对来说较低，这样使得主线程会触发过量的命中测试以及JS代码，造成性能损耗。
优化：浏览器会合并这些连续的事件，延迟到下一帧渲染是执行，也就是**requestAnimationFrame**之前。对于非连续性的事件，会直接派发给主线程去执行。